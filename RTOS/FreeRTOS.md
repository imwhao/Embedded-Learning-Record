# RTOS 入门
## 裸机与 RTOS 特点
裸机：裸机又称为前后台系统，前台系统指的中断服务函数，后台系统指的大循环，即应用程序。 

裸机特点：
1. 实时性差：应用程序轮流执行
2. delay：空等待，CPU 不执行其他代码
3. 结构臃肿：实现功能都放在无限循环

RTOS：RTOS 全称为：Real Time OS，就是实时操作系统，强调的是实时性。

RTOS 特点：
1. 分而治之：实现功能划分为多个任务
2. 延时函数：任务调度（高优先级任务进入延时后可把 CPU 使用权交给低优先级任务，待高优先级任务延时结束后收回使用权）
3. 抢占式：高优先级任务抢占低优先级任务
4. 任务堆栈：每个任务都有自己的栈空间，用于保存局部变量以及任务的上下文信息
注意：中断可以打断任意任务。任务可以同等优先级。

## FreeRTOS 简介/基础知识
FreeRTOS 是一个免费的嵌入式实时操作系统。

特点：
1. 免费开源：可商用
2. 可裁剪：FreeRTOS 的核心代码 9000+行，包含在 3 个 `.c` 文件中
3. 简单：简单易用，可移植性非常好
4. 优先级不限：任务优先级分配没有限制，多任务可同一优先级（若所使用最高优先级算法为硬件，则受限于 MCU 架构）
5. 任务不限：可创建的实时任务数量没有软件限制（硬件限制取决于堆栈大小）
6. 抢占/协程/时间片：支持抢占式，协程式、时间片流转任务调度

### 任务调度
FreeRTOS 支持三种任务调度方式：
1. 抢占式调度：主要是针对优先级不同的任务，每个任务都有一个优先级，优先级高的任务可以抢占优先级低的任务（数值越大优先级越高）
2. 时间片调度：主要针对优先级相同的任务，当多个任务的优先级相同时，任务调度器会在每一次系统时钟节拍到的时候切换任务，时间片的大小取决于滴答定时器时钟频率
3. 协程式调度：当前执行任务将会一直运行，同时高优先级的任务不会抢占低优先级任务（官方不再更新）

### 任务状态
FreeRTOS 中任务共存在 4 种状态：
1. 运行态：正在执行的任务处于运行态（在 stm32 中同一时间仅有一个任务处于运行态）
2. 就绪态：如果该任务已经能够被执行，但当前还未被执行，那么该任务处于就绪态
3. 阻塞态：如果一个任务因延时或等待外部事件发生，那么这个任务就处于阻塞态
4. 挂起态：类似暂停，调用函数 `vTaskSuspend()` 进入挂起态，需要调用解挂函数 `vTaskResume()` 才可以进入就绪态
注：只有就绪态能转变成运行态。这四种状态中，除了运行态，其他三种任务状态的任务都有其对应的任务状态列表。调度器总是在所有处于就绪列表的任务中选择具有最高优先级的任务来执行。

# FreeRTOS 移植
移植步骤：
1. 添加 FreeRTOS 源码：将 FreeRTOS 源码添加至基础工程、头文件路径等
2. 添加 `FreeRTOSConfig.h` 配置文件
3. 修改 SYSTEM 文件：修改 SYSTEM 文件中的 `sys.c`、`delay.c`、`usart.c`
4. 修改中断相关文件：修改 Systick 中断、SVC 中断、PendSV 中断
5. 添加应用程序：验证移植是否成功

系统配置文件：
- 『INCLUDE』：配置 FreeRTOS 中可选的 API 函数
- 『config』：完成 FreeRTOS 的功能配置和裁剪
- 其他配置项：PendSV 宏定义、SVC 宏定义

# 任务创建和删除
## 任务创建和删除的 API 函数
任务创建和删除的本质就是调用 FreeRTOS 的 API 函数

| API 函数              | 描述             |
| --------------------- | ---------------- |
| `xTaskCreate()`       | 动态方式创建任务 |
| `xTaskCreateStatic()` | 静态方式创建任务 |
| `vTaskDelete()`       | 删除任务         |

- 动态创建任务：任务的任务控制块以及任务的栈空间所需的内存，均由 FreeRTOS 从 FreeRTOS 管理的堆中分配
- 静态创建任务：任务的任务控制块以及任务的栈空间所需的内存，需用户分配提供


## 任务创建和删除
实现动态创建任务流程：
1. 将宏 `configSUPPORT_DYNAMIC_ALLOCATION` 配置为 1
2. 定义函数入口参数
3. 编写任务函数
用起来只需要以上三步。此函数创建的任务会立刻进入就绪态，由任务调度器调度运行

静态创建任务使用流程：
1. 需将宏 `configSUPPORT_STATIC_ALLOCATION` 配置为 1
2. 定义空闲任务 & 定时器任务的任务堆栈及 TCB
3. 实现两个接口函数
	1. `vApplicationGetIdleTaskMemory()`
	2. `vApplicationGetTimerTaskMemory()`
4. 定义函数入口参数
5. 编写任务函数
注：静态创建任务的任务句柄是由 `xTaskCreateStatic()` 返回的，动态创建任务直接指定句柄。

动态方式创建任务与静态方式创建任务比较：
1. 在实际应用中，动态方式创建任务相对简单，比较常用，除非有特殊需求，一般都会用动态方式创建任务
2. 静态创建可将任务堆栈放置在指定的内存位置，并且无需关心对内存分配失败的处理

删除任务流程：
1. 使用删除任务函数，需将宏 `INCLUDE_vTaskDelete` 配置为 1
2. 入口参数输入需要删除的任务句柄 **（NULL 代表删除本身）**
注：静态创建的任务申请的内存需要用户在任务被删除前提前释放，否则将导致内存泄漏。 

# 任务挂起和恢复
任务的挂起与恢复的 API 函数

| API 函数             | 描述             |
| -------------------- | ---------------- |
| `VTaskSuspend()`     | 挂起任务         |
| `vTaskResume()`      | 恢复被挂起的任务 |
| `vTaskResumeFromISR` | 在中断中恢复被挂起的任务                 |
注：中断服务程序中要调用 FreeRTOS 的 API 函数则中断优先级不能高于 FreeRTOS 所管理的最高优先级（5~15）且中断要全部设置为抢占式。

# FreeRTOS 中断管理
对于 STM32 中断的介绍和中断优先级分组的配置见 [STM32 学习笔记中断部分](https://github.com/imwhao/Embedded-Learning-Record/blob/main/stm32/Notes.md#%E4%B8%AD%E6%96%AD)

注意：
1. 低于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 优先级的中断里才允许调用 FreeRTOS 的 API 函数
2. FreeRTOS 为了方便配置，将中断优先级分组配置为 `NVIC_PriorityGroup_4`，0~15 级抢占优先级，0 级子优先级。（在 `HAL_Init()` 中调用函数 `HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4)` 即可完成设置）
3. 中断优先级数值越小越优先，任务优先级数值越大越优先

FreeRTOS 将 PendSV 和 SysTick 设置为最低优先级，保证系统任务切换不会阻塞其他中断的响应。

FreeRTOS 所使用的中断管理利用的是 `BASEPRI` 寄存器，屏蔽优先级低于某一个阈值的中断。比如：`BASEPRI` 设置为 0x50（低 4 位不被使用），代表中断优先级在 5~15 内的均被屏蔽，0~4 级的中断优先级正常执行。

# FreeRTOS 临界段代码保护及调度器挂起与恢复
## 临界区代码保护
临界段代码也叫临界区，是指那些必须完整运行，不能被打断的代码段。

适用场合如：
1. 外设：需严格按照时序初始化的外设：IIC、SPI 等等
2. 系统：系统自身需求
3. 用户：用户需求

临界段代码保护函数：

| 函数                            | 描述             |
| ------------------------------- | ---------------- |
| `taskENTER_CRITICAL()`          | 任务级进入临界段 |
| `taskEXIT_CRITICAL()`           | 任务级退出临界段 |
| `taskENTER_CRITICAL_FROM_ISR()` | 中断级进入临界段 |
| `taskEXIT_CRITICAL_FROM_ISR()`  | 中断级退出临界段                 |
中断级进入临界段函数有返回值，需保存下来在退出临界段时作为参数传入 `taskEXIT_CRITICAL_FROM_ISR()`

特点：
1. 成对使用
2. 支持嵌套（多次进入临界区，需要多次退出才会开中断）
3. 尽量保持临界段耗时短

## 任务调度器的挂起与恢复
挂起任务调度器，调用此函数不需要关闭中断

| 函数                | 描述           |
| ------------------- | -------------- |
| `vTaskSuspendAll()` | 挂起任务调度器 |
| `xTaskResumeAll()`  | 恢复任务调度器 |

特点：
1. 与临界区不一样的是，挂起任务调度器，未关闭中断
2. 它仅仅是防止了任务之间的资源争夺，中断照样可以直接响应
3. 挂起调度器的方式，适用于临界区位于任务与任务之间，既不用去延时中断，又可以做到临界区的安全

# 列表和列表项
## 介绍
列表是 FreeRTOS 中的一个数据结构，概念上和链表有点类似，列表被用来跟踪 FreeRTOS 中的任务。列表项就是存放在列表中的项目。

列表相当于链表，列表项相当于节点，FreeRTOS 中的列表是一个**双向环形链表**。

列表结构体：
```c
typedef struct xLIST
{

      listFIRST_LIST_INTEGRITY_CHECK_VALUE  /* 校验值 */
      volatile UBaseType_t uxNumberOfItems;  /* 列表中的列表项数量（不包括末尾列表项） */
      ListItem_t * configLIST_VOLATILE pxIndex  /* 用于遍历列表项的指针 */
      MiniListItem_t xListEnd  /* 末尾列表项 */
      listSECOND_LIST_INTEGRITY_CHECK_VALUE  /* 校验值 */

} List_t;
```

列表项结构体：
```c
struct xLIST_ITEM
{
	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE  /* 用于检测列表项的数据完整性 */
	configLIST_VOLATILE TickType_t xItemValue  /* 列表项的值 */
	struct xLIST_ITEM * configLIST_VOLATILE pxNext  /* 下一个列表项 */
	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious  /* 上一个列表项 */
	void * pvOwner  /* 列表项的拥有者（通常是任务控制块） */
	struct xLIST * configLIST_VOLATILE pxContainer;   /* 列表项所在列表 */
	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE  /* 用于检测列表项的数据完整性 */
};
typedef struct xLIST_ITEM ListItem_t;
```

迷你列表项（仅用于标记列表的末尾和挂载其他插入列表中的列表项）：
```c
struct xMINI_LIST_ITEM
{
	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE   /* 用于检测数据完整性 */
	configLIST_VOLATILE TickType_t xItemValue;  /* 列表项的值 */
	struct xLIST_ITEM * configLIST_VOLATILE pxNext;  /* 上一个列表项 */
	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; /* 下一个列表项 */
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;
```

## 列表相关 API 函数
| 函数                    | 描述               |
| ----------------------- | ------------------ |
| `vListInitialise()`     | 初始化列表         |
| `vListInitialiseItem()` | 初始化列表项       |
| `vListInsertEnd()`      | 列表插入列表项（插入到列表 `pxIndex` 指针指向的列表项前面，一种无序的插入方法） |
| `vListInsert()`         | 列表插入列表项（列表项值升序插入）    |
| `uxListRemove()`        | 列表移除列表项                   |

# 任务调度
## 系统启动流程
1. 函数 `vTaskStartScheduler()` 用于启动任务调度器，任务调度器启动后，FreeRTOS 便会开始进行任务调度，除非调用函数 `xTaskEndScheduler()` 停止任务调度器，否则不会再返回。
2. 函数 `xPortStartScheduler()` 完成启动任务调度器中与硬件架构相关的配置部分，以及启动第一个任务。
3. 函数 `prvStartFirstTask()` 用于初始化启动第一个任务前的环境，主要是重新设置 MSP 指针，并使能全局中断。
4. 当使能了全局中断，并且手动触发 SVC 中断后，就会进入到 SVC 的中断服务函数中。SVC 的中断服务函数为 `vPortSVCHandler()`，用来跳转到第一个任务函数中去。

## 任务切换
任务切换的本质就是 CPU 寄存器的切换。

FreeRTOS 在进行任务切换的时候，会将 CPU 的运行状态，在当
前任务在进行任务切换前，进行保存，保存到任务的任务栈中，然后从切换后运行任务的任务栈中恢复切换后运行任务在上一次被切换时保存的 CPU 信息，保存现场和恢复现场统称任务切换（上下文切换）。

任务切换的过程在**PendSV 中断服务函数**里边完成。

PendSV 中断是如何触发的？
1. 滴答定时器中断调用
2. 执行 FreeRTOS 提供的相关 API 函数 `portYIELD()`
本质：通过向中断控制和状态寄存器 ICSR 的 bit28 写入 1 挂起 PendSV 来启动 PendSV 中断。

# 时间片调度
**同等优先级任务**轮流地享有相同的 CPU 时间（可设置），叫时间片。在 FreeRTOS 中，一个时间片就等于 SysTick 中断周期。

注意：
1. 一个时间片的大小取决于滴答定时器中断频率
2. 任务阻塞让出 CPU，没有用完的时间片时间不会再次使用，下次还是按照一个时间片的时钟节拍运行
3. 使用时间片调度需把宏 `configUSE_TIME_SLICING` 和 `configUSE_PREEMPTION` 置 1

# 任务相关 API 函数
FreeRTOS 任务相关 API 函数介绍：

| 函数                            | 描述                             |
| ------------------------------- | -------------------------------- |
| `uxTaskPriorityGet()`           | 获取任务优先级                   |
| `vTaskPrioritySet()`            | 设置任务优先级                   |
| `uxTaskGetNumberOfTasks()`      | 获取系统中任务的数量             |
| `uxTaskGetSystemState()`        | 获取所有任务状态信息             |
| `vTaskGetInfo()`                | 获取指定单个的任务信息           |
| `XTaskGetCurrentTaskHandle()`   | 获取当前任务的任务句柄           |
| `xTaskGetHandle()`              | 根据任务名获取该任务的任务句柄   |
| `uxTaskGetStackHighWaterMark()` | 获取任务的任务栈历史剩余最小值   |
| `eTaskGetState()`               | 获取任务状态                     |
| `VTaskList()`                   | 以『表格形式』获取所有任务的信息 |
| `vTaskGetRunTimeStats()`        | 获取任务的运行时间                                 |

# 时间管理
1. 相对延时：`vTaskDelay()` 指每次延时都是从执行函数 `vTaskDelay()` 开始，直到延时指定的时间结束
2. 绝对延时：`xTaskDelayUntil()` 将整个任务的运行周期看成一个整体，适用于需要按照一定频率执行的任务

延时函数的流程：正在运行的任务调用延时函数会将此任务移除就绪列表，并添加到阻塞列表中。滴答中断里边进行计时，判断阻塞时间是否到达，如果到达将从阻塞列表中移除，添加到就绪列表。

# 队列
## 简介
队列是任务到任务、任务到中断、中断到任务数据交流的一种机制（消息传递）。FreeRTOS 基于队列，实现了多种功能，其中包括队列集、互斥信号量、计数型信号量、二值信号量、递归互斥信号量。

使用全局变量在 OS 中进行数据交流的弊端：数据无保护，导致数据不安全，当多个任务同时对该变量操作时，数据易受损。

FreeRTOS 队列特点：
1. 数据入队出队方式：队列通常采用『先进先出』（FIFO）的数据存储缓冲机制，即先入队的数据会先从队列中被读取。FreeRTOS 中也可配置为『后进先出』LIFO 方式
2. 数据传递方式：FreeRTOS 中队列采用实际值传递，即将数据拷贝到队列中进行传递，FreeRTOS 采用拷贝数据传递，也可以传递指针，所以在传递较大的数据的时候采用指针传递
3. 多任务访问：队列不属于某个任务，任何任务和中断都可以向队列发送/读取消息
4. 出队、入队阻塞：当任务向一个队列发送消息时，可以指定一个阻塞时间，假设此时当队列已满无法入队
	1. 若阻塞时间为 0：直接返回不会等待
	2. 若阻塞时间为 0~port_MAX_DELAY：等待指定的阻塞时间，若在该时间内还无法入队，超时后直接返回不再等待
	3. 若阻塞时间为 port_MAX_DELAY：死等，一直等到可以入队为止。
	4. 出队阻塞与入队阻塞类似

多个任务在阻塞队列中，先出队的为优先级高的任务，若任务优先级相同，出队等待时间长的任务。

创建队列相关 API 函数介绍：

| 函数                  | 描述             |
| --------------------- | ---------------- |
| `xQueueCreat()`       | 动态方式创建队列 |
| `xQueueCreatStatic()` | 静态方式创建队列 |

往队列写入消息 API 函数：

| 函数                         | 描述                                      |
| ---------------------------- | ----------------------------------------- |
| `xQueueSend()`               | 往队列的末尾写入消息                      |
| `xQueueSendToBack()`         | 同 `xQueueSend()`                         |
| `xQueueSendToFront()`        | 往队列的头部写入消息                      |
| `xQueueOverwrite()`          | 覆写队列消息（只用于队列长度为 1 的情况） |
| `xQueueSendFromISR()`        | 在中断中往队列的尾部写入消息              |
| `xQueueSendToBackFromISR()`  | 同 `xQueueSendFromISR()`                  |
| `xQueueSendToFrontFromISR()` | 在中断中往队列的头部写入消息              |
| `xQueueOverwriteFromISR()`     |  在中断中覆写队列消息（只用于队列长度为 1 的情况）                                         |

从队列读取消息 API 函数：

| 函数              | 描述                           |
| ----------------- | ------------------------------ |
| `xQueueReceive()` | 从队列头部读取消息，并删除消息 |
| `xQueuePeek()`    | 从队列头部读取消息             |
| `xQueueReceiveFromISR()` | 在中断中从队列头部读取消息，并删除消息 |
| `xQueuePeekFromISR()`    | 在中断中从队列头部读取消息             |

# 信号量
## 介绍
信号量是一种解决同步问题的机制，可以实现对共享资源的有序访问。

队列与信号量对比：

| 队列                                                         | 信号量                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可以容纳多个数据；<br />创建队列有两部分内存：队列结构体+队列项存储空间 | 仅存放计数值，无法存放其他数据；<br />创建信号量，只需分配信号量结构体 |
| 写入队列：当队列满时，可阻塞；                               | 释放信号量：不可阻塞，计数值++<br />当计数值为最大时，返回失败 |
|读取队列：当队列为空时，可阻塞；| 读取信号量：计数值--，<br />当没有资源时，可阻塞             |

## 二值信号量
二值信号量的本质是一个队列长度为 1 的队列，该队列就只有空和满两种情况，这就是二值的含义。二值信号量通常用于互斥访问或任务同步，与互斥信号量比较类似，但是二值信号量有可能导致优先级翻转的问题，所以二值信号量更适合用于同步。

二值信号量相关 API 函数：

| 函数                             | 描述                       |
| -------------------------------- | -------------------------- |
| `xSemaphoreCreateBinary()`       | 使用动态方式创建二值信号量 |
| `xSemaphoreCreateBinaryStatic()` | 使用静态方式创建二值信号量 |
| `xSemaphoreGive()`               | 释放信号量                 |
| `xSemaphoreGiveFromISR()`        | 在中断中释放信号量         |
| `xSemaphoreTake()`               | 获取信号量                 |
| `xSemaphoreTakeFromISR()`        | 在中断中获取信号量         |

## 计数型信号量
计数型信号量相当于队列长度大于 1 的队列，因此计数型信号量能够容纳多个资源，这是在计数型信号量被创建时确定的。

计数型信号量适用场合：
1. 事件计数
2. 资源管理

计数型信号量相关 API 函数：

| 函数                               | 描述                         |
| ---------------------------------- | ---------------------------- |
| `xSemaphoreCreateCounting()`       | 使用动态方法创建计数型信号量 |
| `xSemaphoreCreateCountingStatic()` | 使用静态方法创建计数型信号量 |
| `uxSemaphoreGetCount()`            | 获取信号量的计数值           |
计数型信号量的释放与获取与二值信号量相同。

## 优先级翻转
优先级翻转：高优先级的任务反而慢执行，低优先级的任务反而优先执行。

优先级翻转在抢占式内核中是非常常见的，但是在实时操作系统中是不允许出现优先级翻转的，因为优先级翻转会破坏任务的预期顺序，可能会导致未知的严重后果。在使用二值信号量的时候，经常会遇到优先级翻转的问题。

## 互斥信号量
互斥信号量其实就是一个拥有**优先级继承**的二值信号量，在同步的应用中二值信号量最适合。互斥信号量适合用于那些需要互斥访问的应用中。

优先级继承：当一个互斥信号量正在被一个低优先级的任务持有时，如果此时有个高优先级的任务也尝试获取这个互斥信号量，那么这个高优先级的任务就会被阻塞。不过这个高优先级的任务会将低优先级任务的优先级提升到与自己相同的优先级。优先级继承并不能完全的消除优先级翻转的问题，它只是尽可能的降低优先级翻转带来的影响。

注意：互斥信号量不能用于中断服务函数中，原因如下：
1. 互斥信号量有优先级继承的机制，但是中断不是任务，没有任务优先级，所以互斥信号量只能用于任务中，不能用于中断服务函数。
2. 中断服务函数中不能因为要等待互斥信号量而设置阻塞时间进入阻塞态。

创建互斥信号量函数：

| 函数                            | 描述                       |
| ------------------------------- | -------------------------- |
| `xSemaphoreCreateMutex()`       | 使用动态方法创建互斥信号量 |
| `xSemaphoreCreateMutexStatic()` | 使用静态方法创建互斥信号量 |
互斥信号量的释放和获取函数与二值信号量相同！只不过互斥信号量不支持中断调用。

**注意：创建互斥信号量时，会主动释放一次信号量。**

# 队列集
一个队列只允许任务间传递的消息为同一种数据类型，如果需要在任务间传递不同数据类型的消息时，就可以使用队列集。

作用：用于对多个队列或信号量进行『监听』，其中不管哪一个消息到来，都可让任务退出阻塞队列。

队列集相关 API 函数：

| 函数                           | 描述                                 |
| ------------------------------ | ------------------------------------ |
| `xQueueCreatSet()`             | 创建队列集                           |
| `xQueueAddToSet()`             | 队列添加到队列集中                   |
| `xQueueRemoveFromSet()`        | 从队列集中移除队列                   |
| `xQueueSelectFromSet()`        | 获取队列集中有有效消息的队列         |
| `xQueueSelectFromSetFromISR()` | 在中断中获取队列集中有有效消息的队列 |
队列中没有有效消息才可以被移除或添加。

# 事件标志组
事件标志位：用一个位来表示事件是否发生。

事件标志组是一组事件标志位的集合，可以简单的理解事件标志组就是一个整数。

事件标志组的特点：
- 它的每一个位表示一个事件（高 8 位不算）
- 每一位事件的含义，由用户自己决定
- 任意任务和中断都可以读写这些位
- 可以等待某一位成立，或者等待多位同时成立

事件标志组与信号量、队列的区别：

| 功能         | 唤醒对象                                                       | 事件清除                                                       |
| ------------ | -------------------------------------------------------------- | -------------------------------------------------------------- |
| 队列、信号量 | 事件发生时，只会唤醒一个任务                                   | 是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了 |
| 事件标志组   | 事件发生时，会唤醒所有符合条件的任务，可以理解为『广播』的作用 | 被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件     |

事件标志组相关 API 函数介绍：

| 函数                            | 描述                       |
| ------------------------------- | -------------------------- |
| `xEventGroupCreate()`           | 使用动态方式创建事件标志组 |
| `XEventGroupCreateStatic()`     | 使用静态方式创建事件标志组 |
| `xEventGroupClearBits()`        | 清零事件标志位             |
| `xEventGroupClearBitsFromISR()` | 在中断中清零事件标志位     |
| `xEventGroupSetBits()`          | 设置事件标志位             |
| `xEventGroupSetBitsFromISR()`   | 在中断中设置事件标志位     |
| `xEventGroupWaitBits()`         | 等待事件标志位             |
| `xEventGroupSync()`             | 设置事件标志位，并等待事件标志位                           |

# 任务通知
## 简介
任务通知：用来通知任务。任务控制块中的结构体成员变量 ulNotifiedValue 就是这个通知值。

使用队列、信号量、信号标志组时都需另外创建一个结构体，通过中间的结构体进行间接通信；使用任务通知时，任务结构体 TCB 中就包含了内部对象，可以直接接收别人发过来的『通知』。

只要合理、灵活的利用任务通知的特点，可以在一些场合中替代队列、信号量、事件标志组。

任务通知的优势：
1. 效率更高：使用任务通知向任务发送事件或数据比使用队列、事件标志组或信号量快得多
2. 使用内存更小：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体

任务通知的劣势：
1. 无法发送数据给 ISR（中断服务函数）：ISR 没有任务结构体，所以无法给 ISR 发送数据。但是 ISR 可以使用任务通知的功能发数据给任务
2. 无法广播给多个任务：任务通知只能是被指定的一个任务接收并处理
3. 无法缓存多个数据：任务通知是通过更新任务通知值来发送数据的，任务结构体中只有一个任务通知值，只能保持一个数据
4. 发送受阻不支持阻塞

任务通知值的更新方式：
- 计数值（数值累加，类似信号量）
- 相应位置 1（类似事件标志组）
- 任意数值（支持覆写和不覆写，类似队列）

任务通知状态：
- 任务未等待通知：任务通知默认的初始化状态
- 等待通知：接收方已经准备好了（调用了接收任务通知函数），等待发送方通知
- 等待接收：发送方已经发送出去（调用了发送任务通知函数），等待接收方接收

任务通知相关 API 函数（注：发送通知 API 函数可以用于任务和中断服务函数中，接收通知 API 函数只能用在任务中）：

| 函数                        | 描述                                                                                                                                   |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `xTaskNotify()`             | 发送通知，带有通知值                                                                                                                   |
| `xTaskNotifyAndQuery()`     | 发送通知，带有通知值并且保留任务的原通知值                                                                                             |
| `xTaskNotifyGive()`         | 发送通知，不带通知值                                                                                                                   |
| `xTaskNotifyxxxxxFromISR()` | 在中断中发送任务通知                                                                                                                   |
| `ulTaskNotifyTake()`        | 获取任务通知，可以设置在退出此函数的时候将任务通知值清零或减一。当任务通知用作二值信号量或者计数信号量的时候，使用此函数来获取信号量。 |
| `xTaskNotifyWait()`         | 获取任务通知，比 `ulTaskNotifyTake()` 更为复杂，可获取通知值和清除通知值的指定位                                                       |

## 信号量模拟实验
发送任务通知值使用 `xTaskNotifyGive()`，接收任务通知值使用 `ulTaskNotifyTake()`。若接收函数第一个参数为 pdTRUE 则模拟二值信号量，若为 pdFALSE 模拟计数型信号量，每次获取后值-1。

## 事件标志组和队列模拟实验
发送任务通知使用 `xTaskNotify()` 或 `xTaskNotifyAndQuery()`，获取任务通知使用 `xTaskNotifyWait()`。

# 软件定时器
定时器：从指定的时刻开始，经过一个指定时间，然后触发一个超时事件，用户可自定义定时器的周期。

硬件定时器：芯片本身自带的定时器模块，硬件定时器的精度一般很高，每次在定时时间到达之后就会自动触发一个中断，用户在中断服务函数中处理信息。

软件定时器：是指有定时功能的软件，可设置定时周期，当指定时间到达后要调用回调函数（也称超时函数），用户在回调函数中处理信息。

软件定时器优点：
- 硬件定时器数量有限，而软件定时器理论上只需有足够内存，就可以创建多个
- 使用简单、成本低

软件定时器缺点：软件定时器相对硬件定时器来说，精度没有那么高（因为它以系统时钟为基准，系统时钟中断优先级又是最低，容易被打断）。对于需要高精度要求的场合，不建议使用软件定时器。

FreeRTOS 软件定时器特点：
- 可裁剪：软件定时器是可裁剪可配置的功能，如果要使能软件定时器，需将 configUSE_TIMERS 配置项配置成 1
- 单次和周期：软件定时器支持设置成单词定时器或周期定时器

注意：软件定时器的超时回调函数是由**软件定时器服务任务**调用的，软件定时器的超时回调函数本身不是任务，因此不能在该回调函数中使用可能会导致任务阻塞的 API 函数。

软件定时器服务任务：在调用函数 `vTaskStartScheduler()` 开启任务调度器的时候，会创建一个用于管理软件定时器的任务，这个任务就叫做软件定时器服务任务。

软件定时器服务任务作用：
1. 负责软件定时器超时的逻辑判断
2. 调用超时软件定时器的超时回调函数
3. 处理软件定时器命令队列

注意：软件定时器的超时回调函数是在软件定时器服务任务中被调用的，服务任务不是专为某个定时器服务的，它还要处理其他定时器。所以，定时器的回调函数不要影响其他定时器：
1. 回调函数要尽快实行，不能进入阻塞状态，即不能调用那些会阻塞任务的 API 函数，如 `vTaskDelay()`
2. 访问队列或者信号量的非零阻塞时间的 API 函数也不能调用

FreeRTOS 提供了两种软件定时器：
- 单次定时器：单次定时器一旦定时超时，只会执行一次其软件定时器超时回调函数，不会自动重新开启定时，不过可以被手动重新开启
- 周期定时器：周期定时器一旦启动以后就会在执行完回调函数以后自动重新启动，从而周期性地执行其软件定时器回调函数

FreeRTOS 软件定时器相关 API 函数：

| 函数                          | 描述                         |
| ----------------------------- | ---------------------------- |
| `xTimerCreate()`              | 动态方式创建软件定时器       |
| `xTimerCreateStatic()`        | 静态方式创建软件定时器       |
| `xTimerStart()`               | 开启软件定时器定时           |
| `xTimerStartFromISR()`        | 在中断中开启软件定时器定时   |
| `xTimerStop()`                | 停止软件定时器定时           |
| `xTimerStopFromISR()`         | 在中断中停止软件定时器定时   |
| `xTimerReset()`               | 复位软件定时器定时           |
| `xTimerResetFromISR()`        | 在中断中复位软件定时器定时   |
| `xTimerChangePeriod()`        | 更改软件定时器的定时超时时间 |
| `xTimerChangePeriodFromISR()` | 在中断中更改定时超时时间     |

# Tickless 低功耗模式
FreeRTOS 提供了一个叫 Tickless 的低功耗模式，方便带 FreeRTOS 操作系统的应用开发。

Tickless 低功耗模式设计思想：为了可以降低功耗，又不影响系统运行，可以在本该空闲任务执行的期间，让 MCU 进入相应的低功耗模式；当其他任务准备运行的时候，唤醒 MCU 退出低功耗模式。

Tickless 模式相关配置项：
- `configUSE_TICKLESS_IDLE` 此宏用于使能低功耗 Tickless 模式
	- 0：不使能
	- 1：使能
	- 2：自行实现低功耗模式
- `configEXPECTED_IDLE_TIME_BEFORE_SLEEP` 此宏用于定义系统进入相应低功耗模式的最短时长
- `configPRE_SLEEP_PROCESSING(x)` 此宏用于定义需要在系统进入低功耗模式前执行的事务，如：进入低功耗前关闭外设时钟，以达到降低功耗的目的
- `configPOST_SLEEP_PROCESSING(x)` 此宏用于定义需要在系统退出低功耗模式后执行的事务，如：退出低功耗后开启之前关闭的外设时钟，以使系统能够正常运行

# FreeRTOS 内存管理
除了 FreeRTOS 提供的动态内存管理方法，标准的 C 库也提供了函数 `malloc()` 和函数 `free()` 来实现动态地申请和释放内存。

为什么不用标准的 C 库自带的内存管理算法？（标准 C 库动态内存管理方法缺点）
- 占用大量的代码空间，不适合用在资源紧缺的嵌入式系统中
- 没有线程安全的相关机制
- 运行有不确定性，每次调用这些函数时花费的时间可能都不相同
- 内存碎片化

因此，FreeRTOS 提供了多种动态内存管理的算法，可针对不同的嵌入式系统，如下所示：

| 算法     | 优点                                           | 缺点                                           |
| -------- | ---------------------------------------------- | ---------------------------------------------- |
| `heap_1` | 分配简单，时间确定                             | 只允许申请内存，不允许释放内存                 |
| `heap_2` | 允许申请和释放内存                             | 不能合并相邻的空闲内存块，会产生碎片，时间不定 |
| `heap_3` | 直接调用 C 库函数 `malloc()` 和 `free()`，简单 | 速度慢，时间不定                               |
| `heap_4` | 相邻空闲内存可合并，减少内存碎片的产生         | 时间不定                                       |
| `heap_5` | 能够管理多个非连续内存区域的 `heap_4`          | 时间不定                                       |

FreeRTOS 内存管理相关 API 函数介绍：

| 函数                                     | 描述                   |
| ---------------------------------------- | ---------------------- |
| `void *pvPortMalloc(size_t xWantedSize)` | 申请内存               |
| `void vPortFree(void *pv`                | 释放内存               |
| `size_t xPortGetFreeHeapSize(void)`      | 获取当前空闲内存的大小 |





