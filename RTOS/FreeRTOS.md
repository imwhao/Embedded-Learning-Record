# RTOS 入门
## 裸机与 RTOS 特点
裸机：裸机又称为前后台系统，前台系统指的中断服务函数，后台系统指的大循环，即应用程序。 

裸机特点：
1. 实时性差：应用程序轮流执行
2. delay：空等待，CPU 不执行其他代码
3. 结构臃肿：实现功能都放在无限循环

RTOS：RTOS 全称为：Real Time OS，就是实时操作系统，强调的是实时性。

RTOS 特点：
1. 分而治之：实现功能划分为多个任务
2. 延时函数：任务调度（高优先级任务进入延时后可把 CPU 使用权交给低优先级任务，待高优先级任务延时结束后收回使用权）
3. 抢占式：高优先级任务抢占低优先级任务
4. 任务堆栈：每个任务都有自己的栈空间，用于保存局部变量以及任务的上下文信息
注意：中断可以打断任意任务。任务可以同等优先级。

## FreeRTOS 简介/基础知识
FreeRTOS 是一个免费的嵌入式实时操作系统。

特点：
1. 免费开源：可商用
2. 可裁剪：FreeRTOS 的核心代码 9000+行，包含在 3 个 `.c` 文件中
3. 简单：简单易用，可移植性非常好
4. 优先级不限：任务优先级分配没有限制，多任务可同一优先级（若所使用最高优先级算法为硬件，则受限于 MCU 架构）
5. 任务不限：可创建的实时任务数量没有软件限制（硬件限制取决于堆栈大小）
6. 抢占/协程/时间片：支持抢占式，协程式、时间片流转任务调度

### 任务调度
FreeRTOS 支持三种任务调度方式：
1. 抢占式调度：主要是针对优先级不同的任务，每个任务都有一个优先级，优先级高的任务可以抢占优先级低的任务（数值越大优先级越高）
2. 时间片调度：主要针对优先级相同的任务，当多个任务的优先级相同时，任务调度器会在每一次系统时钟节拍到的时候切换任务，时间片的大小取决于滴答定时器时钟频率
3. 协程式调度：当前执行任务将会一直运行，同时高优先级的任务不会抢占低优先级任务（官方不再更新）

### 任务状态
FreeRTOS 中任务共存在 4 种状态：
1. 运行态：正在执行的任务处于运行态（在 stm32 中同一时间仅有一个任务处于运行态）
2. 就绪态：如果该任务已经能够被执行，但当前还未被执行，那么该任务处于就绪态
3. 阻塞态：如果一个任务因延时或等待外部事件发生，那么这个任务就处于阻塞态
4. 挂起态：类似暂停，调用函数 `vTaskSuspend()` 进入挂起态，需要调用解挂函数 `vTaskResume()` 才可以进入就绪态
注：只有就绪态能转变成运行态。这四种状态中，除了运行态，其他三种任务状态的任务都有其对应的任务状态列表。调度器总是在所有处于就绪列表的任务中选择具有最高优先级的任务来执行。

# FreeRTOS 移植
移植步骤：
1. 添加 FreeRTOS 源码：将 FreeRTOS 源码添加至基础工程、头文件路径等
2. 添加 `FreeRTOSConfig.h` 配置文件
3. 修改 SYSTEM 文件：修改 SYSTEM 文件中的 `sys.c`、`delay.c`、`usart.c`
4. 修改中断相关文件：修改 Systick 中断、SVC 中断、PendSV 中断
5. 添加应用程序：验证移植是否成功

系统配置文件：
- 『INCLUDE』：配置 FreeRTOS 中可选的 API 函数
- 『config』：完成 FreeRTOS 的功能配置和裁剪
- 其他配置项：PendSV 宏定义、SVC 宏定义

# 任务创建和删除
## 任务创建和删除的 API 函数
任务创建和删除的本质就是调用 FreeRTOS 的 API 函数

| API 函数              | 描述             |
| --------------------- | ---------------- |
| `xTaskCreate()`       | 动态方式创建任务 |
| `xTaskCreateStatic()` | 静态方式创建任务 |
| `vTaskDelete()`       | 删除任务         |

- 动态创建任务：任务的任务控制块以及任务的栈空间所需的内存，均由 FreeRTOS 从 FreeRTOS 管理的堆中分配
- 静态创建任务：任务的任务控制块以及任务的栈空间所需的内存，需用户分配提供


## 任务创建和删除
实现动态创建任务流程：
1. 将宏 `configSUPPORT_DYNAMIC_ALLOCATION` 配置为 1
2. 定义函数入口参数
3. 编写任务函数
用起来只需要以上三步。此函数创建的任务会立刻进入就绪态，由任务调度器调度运行

静态创建任务使用流程：
1. 需将宏 `configSUPPORT_STATIC_ALLOCATION` 配置为 1
2. 定义空闲任务 & 定时器任务的任务堆栈及 TCB
3. 实现两个接口函数
	1. `vApplicationGetIdleTaskMemory()`
	2. `vApplicationGetTimerTaskMemory()`
4. 定义函数入口参数
5. 编写任务函数
注：静态创建任务的任务句柄是由 `xTaskCreateStatic()` 返回的，动态创建任务直接指定句柄。

动态方式创建任务与静态方式创建任务比较：
1. 在实际应用中，动态方式创建任务相对简单，比较常用，除非有特殊需求，一般都会用动态方式创建任务
2. 静态创建可将任务堆栈放置在指定的内存位置，并且无需关心对内存分配失败的处理

删除任务流程：
1. 使用删除任务函数，需将宏 `INCLUDE_vTaskDelete` 配置为 1
2. 入口参数输入需要删除的任务句柄 **（NULL 代表删除本身）**
注：静态创建的任务申请的内存需要用户在任务被删除前提前释放，否则将导致内存泄漏。 

# 任务挂起和恢复
任务的挂起与恢复的 API 函数

| API 函数             | 描述             |
| -------------------- | ---------------- |
| `VTaskSuspend()`     | 挂起任务         |
| `vTaskResume()`      | 恢复被挂起的任务 |
| `vTaskResumeFromISR` | 在中断中恢复被挂起的任务                 |
注：中断服务程序中要调用 FreeRTOS 的 API 函数则中断优先级不能高于 FreeRTOS 所管理的最高优先级（5~15）且中断要全部设置为抢占式。

# FreeRTOS 中断管理
对于 STM32 中断的介绍和中断优先级分组的配置见 [STM32 学习笔记中断部分](https://github.com/imwhao/Embedded-Learning-Record/blob/main/stm32/Notes.md#%E4%B8%AD%E6%96%AD)

注意：
1. 低于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 优先级的中断里才允许调用 FreeRTOS 的 API 函数
2. FreeRTOS 为了方便配置，将中断优先级分组配置为 `NVIC_PriorityGroup_4`，0~15 级抢占优先级，0 级子优先级。（在 `HAL_Init()` 中调用函数 `HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4)` 即可完成设置）
3. 中断优先级数值越小越优先，任务优先级数值越大越优先

FreeRTOS 将 PendSV 和 SysTick 设置为最低优先级，保证系统任务切换不会阻塞其他中断的响应。

FreeRTOS 所使用的中断管理利用的是 `BASEPRI` 寄存器，屏蔽优先级低于某一个阈值的中断。比如：`BASEPRI` 设置为 0x50（低 4 位不被使用），代表中断优先级在 5~15 内的均被屏蔽，0~4 级的中断优先级正常执行。

# FreeRTOS 临界段代码保护及调度器挂起与恢复
## 临界区代码保护
临界段代码也叫临界区，是指那些必须完整运行，不能被打断的代码段。

适用场合如：
1. 外设：需严格按照时序初始化的外设：IIC、SPI 等等
2. 系统：系统自身需求
3. 用户：用户需求

临界段代码保护函数：

| 函数                            | 描述             |
| ------------------------------- | ---------------- |
| `taskENTER_CRITICAL()`          | 任务级进入临界段 |
| `taskEXIT_CRITICAL()`           | 任务级退出临界段 |
| `taskENTER_CRITICAL_FROM_ISR()` | 中断级进入临界段 |
| `taskEXIT_CRITICAL_FROM_ISR()`  | 中断级退出临界段                 |
中断级进入临界段函数有返回值，需保存下来在退出临界段时作为参数传入 `taskEXIT_CRITICAL_FROM_ISR()`

特点：
1. 成对使用
2. 支持嵌套（多次进入临界区，需要多次退出才会开中断）
3. 尽量保持临界段耗时短

## 任务调度器的挂起与恢复
挂起任务调度器，调用此函数不需要关闭中断

| 函数                | 描述           |
| ------------------- | -------------- |
| `vTaskSuspendAll()` | 挂起任务调度器 |
| `xTaskResumeAll()`  | 恢复任务调度器 |

特点：
1. 与临界区不一样的是，挂起任务调度器，未关闭中断
2. 它仅仅是防止了任务之间的资源争夺，中断照样可以直接响应
3. 挂起调度器的方式，适用于临界区位于任务与任务之间，既不用去延时中断，又可以做到临界区的安全

# 列表和列表项
## 介绍
列表是 FreeRTOS 中的一个数据结构，概念上和链表有点类似，列表被用来跟踪 FreeRTOS 中的任务。列表项就是存放在列表中的项目。

列表相当于链表，列表项相当于节点，FreeRTOS 中的列表是一个**双向环形链表**。

列表结构体：
```c
typedef struct xLIST
{

      listFIRST_LIST_INTEGRITY_CHECK_VALUE  /* 校验值 */
      volatile UBaseType_t uxNumberOfItems;  /* 列表中的列表项数量（不包括末尾列表项） */
      ListItem_t * configLIST_VOLATILE pxIndex  /* 用于遍历列表项的指针 */
      MiniListItem_t xListEnd  /* 末尾列表项 */
      listSECOND_LIST_INTEGRITY_CHECK_VALUE  /* 校验值 */

} List_t;
```

列表项结构体：
```c
struct xLIST_ITEM
{
	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE  /* 用于检测列表项的数据完整性 */
	configLIST_VOLATILE TickType_t xItemValue  /* 列表项的值 */
	struct xLIST_ITEM * configLIST_VOLATILE pxNext  /* 下一个列表项 */
	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious  /* 上一个列表项 */
	void * pvOwner  /* 列表项的拥有者（通常是任务控制块） */
	struct xLIST * configLIST_VOLATILE pxContainer;   /* 列表项所在列表 */
	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE  /* 用于检测列表项的数据完整性 */
};
typedef struct xLIST_ITEM ListItem_t;
```

迷你列表项（仅用于标记列表的末尾和挂载其他插入列表中的列表项）：
```c
struct xMINI_LIST_ITEM
{
	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE   /* 用于检测数据完整性 */
	configLIST_VOLATILE TickType_t xItemValue;  /* 列表项的值 */
	struct xLIST_ITEM * configLIST_VOLATILE pxNext;  /* 上一个列表项 */
	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; /* 下一个列表项 */
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;
```

## 列表相关 API 函数
| 函数                    | 描述               |
| ----------------------- | ------------------ |
| `vListInitialise()`     | 初始化列表         |
| `vListInitialiseItem()` | 初始化列表项       |
| `vListInsertEnd()`      | 列表插入列表项（插入到列表 `pxIndex` 指针指向的列表项前面，一种无序的插入方法） |
| `vListInsert()`         | 列表插入列表项（列表项值升序插入）    |
| `uxListRemove()`        | 列表移除列表项                   |

# 任务调度
## 系统启动流程
1. 函数 `vTaskStartScheduler()` 用于启动任务调度器，任务调度器启动后，FreeRTOS 便会开始进行任务调度，除非调用函数 `xTaskEndScheduler()` 停止任务调度器，否则不会再返回。
2. 函数 `xPortStartScheduler()` 完成启动任务调度器中与硬件架构相关的配置部分，以及启动第一个任务。
3. 函数 `prvStartFirstTask()` 用于初始化启动第一个任务前的环境，主要是重新设置 MSP 指针，并使能全局中断。
4. 当使能了全局中断，并且手动触发 SVC 中断后，就会进入到 SVC 的中断服务函数中。SVC 的中断服务函数为 `vPortSVCHandler()`，用来跳转到第一个任务函数中去。

## 任务切换
任务切换的本质就是 CPU 寄存器的切换。

FreeRTOS 在进行任务切换的时候，会将 CPU 的运行状态，在当
前任务在进行任务切换前，进行保存，保存到任务的任务栈中，然后从切换后运行任务的任务栈中恢复切换后运行任务在上一次被切换时保存的 CPU 信息，保存现场和恢复现场统称任务切换（上下文切换）。

任务切换的过程在**PendSV 中断服务函数**里边完成。

PendSV 中断是如何触发的？
1. 滴答定时器中断调用
2. 执行 FreeRTOS 提供的相关 API 函数 `portYIELD()`
本质：通过向中断控制和状态寄存器 ICSR 的 bit28 写入 1 挂起 PendSV 来启动 PendSV 中断。

# 时间片调度
**同等优先级任务**轮流地享有相同的 CPU 时间（可设置），叫时间片。在 FreeRTOS 中，一个时间片就等于 SysTick 中断周期。

注意：
1. 一个时间片的大小取决于滴答定时器中断频率
2. 任务阻塞让出 CPU，没有用完的时间片时间不会再次使用，下次还是按照一个时间片的时钟节拍运行
3. 使用时间片调度需把宏 `configUSE_TIME_SLICING` 和 `configUSE_PREEMPTION` 置 1

# 任务相关 API 函数
FreeRTOS 任务相关 API 函数介绍：

| 函数                            | 描述                             |
| ------------------------------- | -------------------------------- |
| `uxTaskPriorityGet()`           | 获取任务优先级                   |
| `vTaskPrioritySet()`            | 设置任务优先级                   |
| `uxTaskGetNumberOfTasks()`      | 获取系统中任务的数量             |
| `uxTaskGetSystemState()`        | 获取所有任务状态信息             |
| `vTaskGetInfo()`                | 获取指定单个的任务信息           |
| `XTaskGetCurrentTaskHandle()`   | 获取当前任务的任务句柄           |
| `xTaskGetHandle()`              | 根据任务名获取该任务的任务句柄   |
| `uxTaskGetStackHighWaterMark()` | 获取任务的任务栈历史剩余最小值   |
| `eTaskGetState()`               | 获取任务状态                     |
| `VTaskList()`                   | 以『表格形式』获取所有任务的信息 |
| `vTaskGetRunTimeStats()`        | 获取任务的运行时间                                 |

# 时间管理
1. 相对延时：`vTaskDelay()` 指每次延时都是从执行函数 `vTaskDelay()` 开始，直到延时指定的时间结束
2. 绝对延时：`xTaskDelayUntil()` 将整个任务的运行周期看成一个整体，适用于需要按照一定频率执行的任务

延时函数的流程：正在运行的任务调用延时函数会将此任务移除就绪列表，并添加到阻塞列表中。滴答中断里边进行计时，判断阻塞时间是否到达，如果到达将从阻塞列表中移除，添加到就绪列表。

# 队列
## 简介
队列是任务到任务、任务到中断、中断到任务数据交流的一种机制（消息传递）。FreeRTOS 基于队列，实现了多种功能，其中包括队列集、互斥信号量、计数型信号量、二值信号量、递归互斥信号量。

使用全局变量在 OS 中进行数据交流的弊端：数据无保护，导致数据不安全，当多个任务同时对该变量操作时，数据易受损。

FreeRTOS 队列特点：
1. 数据入队出队方式：队列通常采用『先进先出』（FIFO）的数据存储缓冲机制，即先入队的数据会先从队列中被读取。FreeRTOS 中也可配置为『后进先出』LIFO 方式
2. 数据传递方式：FreeRTOS 中队列采用实际值传递，即将数据拷贝到队列中进行传递，FreeRTOS 采用拷贝数据传递，也可以传递指针，所以在传递较大的数据的时候采用指针传递
3. 多任务访问：队列不属于某个任务，任何任务和中断都可以向队列发送/读取消息
4. 出队、入队阻塞：当任务向一个队列发送消息时，可以指定一个阻塞时间，假设此时当队列已满无法入队
	1. 若阻塞时间为 0：直接返回不会等待
	2. 若阻塞时间为 0~port_MAX_DELAY：等待指定的阻塞时间，若在该时间内还无法入队，超时后直接返回不再等待
	3. 若阻塞时间为 port_MAX_DELAY：死等，一直等到可以入队为止。
	4. 出队阻塞与入队阻塞类似

多个任务在阻塞队列中，先出队的为优先级高的任务，若任务优先级相同，出队等待时间长的任务。

创建队列相关 API 函数介绍：

| 函数                  | 描述             |
| --------------------- | ---------------- |
| `xQueueCreat()`       | 动态方式创建队列 |
| `xQueueCreatStatic()` | 静态方式创建队列 |

往队列写入消息 API 函数：

| 函数                         | 描述                                      |
| ---------------------------- | ----------------------------------------- |
| `xQueueSend()`               | 往队列的末尾写入消息                      |
| `xQueueSendToBack()`         | 同 `xQueueSend()`                         |
| `xQueueSendToFront()`        | 往队列的头部写入消息                      |
| `xQueueOverwrite()`          | 覆写队列消息（只用于队列长度为 1 的情况） |
| `xQueueSendFromISR()`        | 在中断中往队列的尾部写入消息              |
| `xQueueSendToBackFromISR()`  | 同 `xQueueSendFromISR()`                  |
| `xQueueSendToFrontFromISR()` | 在中断中往队列的头部写入消息              |
| `xQueueOverwriteFromISR()`     |  在中断中覆写队列消息（只用于队列长度为 1 的情况）                                         |

从队列读取消息 API 函数：

| 函数              | 描述                           |
| ----------------- | ------------------------------ |
| `xQueueReceive()` | 从队列头部读取消息，并删除消息 |
| `xQueuePeek()`    | 从队列头部读取消息             |
| `xQueueReceiveFromISR()` | 在中断中从队列头部读取消息，并删除消息 |
| `xQueuePeekFromISR()`    | 在中断中从队列头部读取消息             |

# 信号量
## 介绍
信号量是一种解决同步问题的机制，可以实现对共享资源的有序访问。

队列与信号量对比：

| 队列                                                         | 信号量                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可以容纳多个数据；<br />创建队列有两部分内存：队列结构体+队列项存储空间 | 仅存放计数值，无法存放其他数据；<br />创建信号量，只需分配信号量结构体 |
| 写入队列：当队列满时，可阻塞；                               | 释放信号量：不可阻塞，计数值++<br />当计数值为最大时，返回失败 |
|读取队列：当队列为空时，可阻塞；| 读取信号量：计数值--，<br />当没有资源时，可阻塞             |

## 二值信号量
二值信号量的本质是一个队列长度为 1 的队列，该队列就只有空和满两种情况，这就是二值的含义。二值信号量通常用于互斥访问或任务同步，与互斥信号量比较类似，但是二值信号量有可能导致优先级翻转的问题，所以二值信号量更适合用于同步。

二值信号量相关 API 函数：

| 函数                             | 描述                       |
| -------------------------------- | -------------------------- |
| `xSemaphoreCreateBinary()`       | 使用动态方式创建二值信号量 |
| `xSemaphoreCreateBinaryStatic()` | 使用静态方式创建二值信号量 |
| `xSemaphoreGive()`               | 释放信号量                 |
| `xSemaphoreGiveFromISR()`        | 在中断中释放信号量         |
| `xSemaphoreTake()`               | 获取信号量                 |
| `xSemaphoreTakeFromISR()`        | 在中断中获取信号量         |

## 计数型信号量
计数型信号量相当于队列长度大于 1 的队列，因此计数型信号量能够容纳多个资源，这是在计数型信号量被创建时确定的。

计数型信号量适用场合：
1. 事件计数
2. 资源管理

计数型信号量相关 API 函数：

| 函数                               | 描述                         |
| ---------------------------------- | ---------------------------- |
| `xSemaphoreCreateCounting()`       | 使用动态方法创建计数型信号量 |
| `xSemaphoreCreateCountingStatic()` | 使用静态方法创建计数型信号量 |
| `uxSemaphoreGetCount()`            | 获取信号量的计数值           |
计数型信号量的释放与获取与二值信号量相同。

## 优先级翻转
优先级翻转：高优先级的任务反而慢执行，低优先级的任务反而优先执行。

优先级翻转在抢占式内核中是非常常见的，但是在实时操作系统中是不允许出现优先级翻转的，因为优先级翻转会破坏任务的预期顺序，可能会导致未知的严重后果。在使用二值信号量的时候，经常会遇到优先级翻转的问题。









